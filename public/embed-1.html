<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neo4j Graph Visualization</title>
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <style>
    :root {
      --primary-color: #4CAF50;
      --primary-dark: #45a049;
      --bg-dark: #1a1a1a;
      --bg-card-dark: rgba(30, 30, 30, 0.95);
      --text-dark: #fff;
      --bg-light: #f5f5f5;
      --bg-card-light: rgba(255, 255, 255, 0.95);
      --text-light: #333;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      --shadow-heavy: 0 8px 30px rgba(0, 0, 0, 0.25);
      --border-radius: 12px;
      --transition: all 0.3s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', sans-serif;
      background: var(--bg-dark);
      color: var(--text-dark);
      overflow: hidden;
      transition: var(--transition);
    }

    /* Light mode styles */
    body.light {
      background: var(--bg-light);
      color: var(--text-light);
    }

    body.light #viz {
      background: #ffffff;
    }

    body.light .controls-container {
      background: var(--bg-card-light);
      color: var(--text-light);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.light .info-panel {
      background: var(--bg-card-light);
      color: var(--text-light);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.light #detail-popup {
      background: #fff;
      color: var(--text-light);
      box-shadow: var(--shadow-heavy);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.light #detail-content {
      background: #f8f8f8;
      color: var(--text-light);
    }

    body.light .detail-panel {
      background: var(--bg-card-light);
      color: var(--text-light);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.light .filter-panel {
      background: var(--bg-card-light);
      color: var(--text-light);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.light .config-panel {
      background: var(--bg-card-light);
      color: var(--text-light);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    /* Fix for light mode text colors */
    body.light .btn {
      color: var(--text-light);
    }
    
    body.light .search-container input {
      color: var(--text-light);
      background: rgba(255, 255, 255, 0.9);
    }
    
    body.light .filter-checkbox label {
      color: var(--text-light);
    }
    
    body.light .config-option label {
      color: var(--text-light);
    }
    
    body.light .controls-title {
      color: var(--text-light);
    }
    
    body.light .info-item {
      color: var(--text-light);
    }

    body.light .filter-checkboxes {
      background: rgba(0, 0, 0, 0.05);
    }

    #viz {
      width: 100vw;
      height: 100vh;
      background: #2a2a2a;
      transition: background-color 0.3s;
    }

    /* Loading Animation */
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 1000;
    }

    #loading.hidden {
      display: none;
    }

    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      border-top: 4px solid var(--primary-color);
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Error Display */
    #error {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #ff4444;
      padding: 24px 40px;
      border-radius: var(--border-radius);
      text-align: center;
      max-width: 500px;
      display: none;
      box-shadow: var(--shadow-heavy);
      z-index: 1000;
    }

    #error.show {
      display: block;
    }

    #error h2 {
      margin-bottom: 12px;
      font-weight: 600;
    }

    /* Controls Panel */
    .controls-container {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--bg-card-dark);
      padding: 16px;
      border-radius: var(--border-radius);
      z-index: 100;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      width: 320px;
      transition: var(--transition);
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .controls-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .controls-title {
      font-weight: 600;
      font-size: 16px;
    }

    .toggle-controls {
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      font-size: 18px;
      padding: 4px;
      border-radius: 4px;
      transition: var(--transition);
    }

    .toggle-controls:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .controls-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      transition: var(--transition);
    }

    .controls-content.collapsed {
      display: none;
    }

    .search-container {
      grid-column: 1 / span 2;
      display: flex;
      margin-bottom: 8px;
    }

    .search-container input {
      flex: 1;
      padding: 10px 14px;
      border-radius: var(--border-radius) 0 0 var(--border-radius);
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.3);
      color: inherit;
      font-size: 14px;
      transition: var(--transition);
    }

    .search-container input:focus {
      outline: none;
      border-color: var(--primary-color);
    }

    .search-container button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 0 var(--border-radius) var(--border-radius) 0;
      cursor: pointer;
      font-size: 14px;
      transition: var(--transition);
    }

    .search-container button:hover {
      background: var(--primary-dark);
    }

    .btn {
      background: rgba(255, 255, 255, 0.1);
      color: inherit;
      border: none;
      padding: 10px 14px;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 14px;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn-primary {
      background: var(--primary-color);
      color: white;
    }

    .btn-primary:hover {
      background: var(--primary-dark);
    }

    .btn-group {
      display: flex;
      gap: 8px;
    }

    .btn-group .btn {
      flex: 1;
    }

    /* Info Panel */
    .info-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: var(--bg-card-dark);
      padding: 16px;
      border-radius: var(--border-radius);
      font-size: 14px;
      z-index: 100;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      transition: var(--transition);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .info-item {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .info-item:last-child {
      margin-bottom: 0;
    }

    .info-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Detail Popup */
    #detail-popup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      color: #fff;
      padding: 24px 32px;
      border-radius: var(--border-radius);
      z-index: 200;
      min-width: 320px;
      max-width: 90vw;
      box-shadow: var(--shadow-heavy);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #detail-title {
      font-weight: 600;
      font-size: 18px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #detail-content {
      background: #111;
      padding: 16px;
      border-radius: 8px;
      max-height: 400px;
      overflow: auto;
      font-size: 14px;
      line-height: 1.5;
      margin-bottom: 16px;
    }

    .detail-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    /* Detail Panel - Top left */
    .detail-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: var(--bg-card-dark);
      padding: 16px;
      border-radius: var(--border-radius);
      z-index: 100;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      width: 300px;
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .detail-panel h3 {
      margin-bottom: 12px;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .detail-panel-content {
      font-size: 14px;
      line-height: 1.5;
    }

    .detail-panel-content pre {
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 6px;
      overflow: auto;
      max-height: 300px;
      font-family: 'Courier New', monospace;
    }

    /* Filter Panel - Improved Design */
    .filter-panel {
      position: absolute;
      top: 100px;
      right: 20px;
      background: var(--bg-card-dark);
      padding: 16px;
      border-radius: var(--border-radius);
      z-index: 100;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      width: 300px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .filter-panel h3 {
      margin-bottom: 16px;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .filter-section {
      margin-bottom: 20px;
    }

    .filter-section h4 {
      margin-bottom: 12px;
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .filter-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 150px;
      overflow-y: auto;
      padding: 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .filter-checkbox {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 0;
      transition: var(--transition);
    }

    .filter-checkbox:hover {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      padding-left: 8px;
    }

    .filter-checkbox input {
      margin: 0;
      cursor: pointer;
      transform: scale(1.1);
    }

    .filter-checkbox label {
      font-size: 13px;
      cursor: pointer;
      flex: 1;
    }

    .filter-actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }

    /* Config Panel */
    .config-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-card-dark);
      padding: 24px;
      border-radius: var(--border-radius);
      z-index: 200;
      box-shadow: var(--shadow-heavy);
      backdrop-filter: blur(10px);
      width: 500px;
      max-width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      display: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .config-panel h3 {
      margin-bottom: 16px;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .config-section {
      margin-bottom: 20px;
    }

    .config-section h4 {
      margin-bottom: 12px;
      font-size: 16px;
      font-weight: 500;
    }

    .config-option {
      margin-bottom: 12px;
    }

    .config-option label {
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
    }

    .config-option select {
      width: 100%;
      padding: 8px 12px;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.3);
      color: inherit;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 14px;
    }

    .config-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 20px;
    }

    /* Toast Notifications */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--primary-color);
      color: white;
      padding: 12px 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      z-index: 1000;
      transform: translateY(100px);
      opacity: 0;
      transition: transform 0.3s, opacity 0.3s;
    }

    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .controls-container {
        width: calc(100vw - 40px);
        right: 20px;
      }
      
      .info-panel {
        width: calc(100vw - 40px);
        left: 20px;
      }
      
      .detail-panel {
        width: calc(100vw - 40px);
        left: 20px;
        top: 80px;
      }
      
      .filter-panel {
        width: calc(100vw - 40px);
        right: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <p>Loading visualization...</p>
  </div>

  <div id="error">
    <h2>Error Loading Visualization</h2>
    <p id="error-message"></p>
  </div>

  <div id="viz"></div>

  <div id="detail-popup">
    <div id="detail-title">
      <span class="detail-icon">üìã</span>
      <span id="detail-title-text"></span>
    </div>
    <pre id="detail-content"></pre>
    <div class="detail-actions">
      <button class="btn" onclick="copyDetail()">üìã Copy</button>
      <button class="btn btn-primary" onclick="closeDetail()">Close</button>
    </div>
  </div>

  <div class="controls-container">
    <div class="controls-header">
      <div class="controls-title">Graph Controls</div>
      <button class="toggle-controls" onclick="toggleControls()">‚àí</button>
    </div>
    <div class="controls-content">
      <div class="search-container">
        <input type="text" id="search-node" placeholder="Search node by name/id">
        <button onclick="searchNode()">üîç</button>
      </div>
      <button class="btn" onclick="toggleFilterPanel()">üîß Filters</button>
      <button class="btn" onclick="toggleConfigPanel()">‚öôÔ∏è Config</button>
      <button class="btn" onclick="toggleDetailPanel()">üìã Details</button>
      <button class="btn" onclick="exportJSON()">üíæ JSON</button>
      <button class="btn" onclick="exportCSV()">üíæ CSV</button>
      <button class="btn" onclick="exportPNG(false)">üñºÔ∏è Viewport</button>
      <button class="btn" onclick="exportPNG(true)">üñºÔ∏è Full Graph</button>
      <button class="btn" onclick="toggleTheme()" id="theme-btn">üåô Light Mode</button>
      <button class="btn" onclick="zoomToFit()">üîé Fit</button>
      <button class="btn" onclick="resetView()">üîÑ Reset</button>
      <button class="btn" onclick="changeLayout()">üìê Change Layout</button>
      <button class="btn" onclick="reload()">‚ü≥ Reload</button>
      <button class="btn" onclick="loadMockData()" style="grid-column: 1 / span 2;">üé≤ Load Mock Data</button>
    </div>
  </div>

  <div class="info-panel">
    <div class="info-item">
      <span class="info-icon">‚óè</span>
      <span id="node-count">Nodes: 0</span>
    </div>
    <div class="info-item">
      <span class="info-icon">‚Üî</span>
      <span id="rel-count">Relationships: 0</span>
    </div>
  </div>

  <!-- Detail Panel moved to top left -->
  <div class="detail-panel" id="detail-panel" style="display: none;">
    <h3>üìã Selected Element</h3>
    <div class="detail-panel-content" id="detail-panel-content">
      Click on a node or relationship to see details here
    </div>
  </div>

  <div class="filter-panel" id="filter-panel" style="display: none;">
    <h3>üîß Filters</h3>
    <div class="filter-section">
      <h4>üìä Node Types</h4>
      <div class="filter-checkboxes" id="node-filter">
        <!-- Will be populated dynamically -->
      </div>
    </div>
    <div class="filter-section">
      <h4>üîó Relationship Types</h4>
      <div class="filter-checkboxes" id="relationship-filter">
        <!-- Will be populated dynamically -->
      </div>
    </div>
    <div class="filter-actions">
      <button class="btn" onclick="selectAllFilters()">Select All</button>
      <button class="btn" onclick="clearFilters()">Clear All</button>
      <button class="btn btn-primary" onclick="toggleFilterPanel()">Close</button>
    </div>
  </div>

  <div class="config-panel" id="config-panel">
    <h3>‚öôÔ∏è Configuration</h3>
    <div class="config-section">
      <h4>Node Labels</h4>
      <div class="config-option">
        <label for="node-label-property">Property to use as node label:</label>
        <select id="node-label-property" class="filter-select">
          <option value="id">ID</option>
          <option value="label">Label</option>
          <!-- Will be populated dynamically with available properties -->
        </select>
      </div>
    </div>
    <div class="config-section">
      <h4>Edge Labels</h4>
      <div class="config-option">
        <label for="edge-label-property">Property to use as edge label:</label>
        <select id="edge-label-property" class="filter-select">
          <option value="label">Type</option>
          <!-- Will be populated dynamically with available properties -->
        </select>
      </div>
    </div>
    <div class="config-actions">
      <button class="btn btn-primary" onclick="applyConfig()">Apply</button>
      <button class="btn" onclick="closeConfigPanel()">Cancel</button>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // Global variables
    let network = null;
    let nodes = null;
    let edges = null;
    let currentEmbedToken = null;
    let isDarkMode = true;
    let controlsCollapsed = false;
    let allNodes = [];
    let allEdges = [];
    let nodeLabelProperty = 'label';
    let edgeLabelProperty = 'label';
    let currentLayout = 'default';

    // Toast notification
    function showToast(message, duration = 3000) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      
      setTimeout(() => {
        toast.classList.remove('show');
      }, duration);
    }

    // Toggle controls visibility
    function toggleControls() {
      controlsCollapsed = !controlsCollapsed;
      const controlsContent = document.querySelector('.controls-content');
      const toggleBtn = document.querySelector('.toggle-controls');
      
      if (controlsCollapsed) {
        controlsContent.classList.add('collapsed');
        toggleBtn.textContent = '+';
      } else {
        controlsContent.classList.remove('collapsed');
        toggleBtn.textContent = '‚àí';
      }
    }

    // Toggle filter panel
    function toggleFilterPanel() {
      const filterPanel = document.getElementById('filter-panel');
      if (filterPanel.style.display === 'none') {
        filterPanel.style.display = 'block';
        populateFilters();
      } else {
        filterPanel.style.display = 'none';
      }
    }

    // Toggle config panel
    function toggleConfigPanel() {
      const configPanel = document.getElementById('config-panel');
      if (configPanel.style.display === 'none') {
        configPanel.style.display = 'block';
        populateConfigOptions();
      } else {
        configPanel.style.display = 'none';
      }
    }

    function closeConfigPanel() {
      document.getElementById('config-panel').style.display = 'none';
    }

    // Toggle detail panel
    function toggleDetailPanel() {
      const detailPanel = document.getElementById('detail-panel');
      if (detailPanel.style.display === 'none') {
        detailPanel.style.display = 'block';
      } else {
        detailPanel.style.display = 'none';
      }
    }

    // Populate filter options with checkboxes
    function populateFilters() {
      if (!allNodes.length || !allEdges.length) return;
      
      // Get unique node types
      const nodeTypes = [...new Set(allNodes.map(node => node.originalLabel || 'Unknown'))];
      const nodeFilter = document.getElementById('node-filter');
      nodeFilter.innerHTML = '';
      
      nodeTypes.forEach(type => {
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'filter-checkbox';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `node-${type}`;
        checkbox.value = type;
        checkbox.checked = true;
        checkbox.addEventListener('change', applyFilters);
        
        const label = document.createElement('label');
        label.htmlFor = `node-${type}`;
        label.textContent = type;
        
        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(label);
        nodeFilter.appendChild(checkboxContainer);
      });
      
      // Get unique relationship types
      const relTypes = [...new Set(allEdges.map(edge => edge.originalType || 'Unknown'))];
      const relFilter = document.getElementById('relationship-filter');
      relFilter.innerHTML = '';
      
      relTypes.forEach(type => {
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'filter-checkbox';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `rel-${type}`;
        checkbox.value = type;
        checkbox.checked = true;
        checkbox.addEventListener('change', applyFilters);
        
        const label = document.createElement('label');
        label.htmlFor = `rel-${type}`;
        label.textContent = type;
        
        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(label);
        relFilter.appendChild(checkboxContainer);
      });
    }

    // Apply filters automatically when checkbox changes
    function applyFilters() {
      const selectedNodeTypes = Array.from(document.querySelectorAll('#node-filter input:checked'))
        .map(checkbox => checkbox.value);
      
      const selectedRelTypes = Array.from(document.querySelectorAll('#relationship-filter input:checked'))
        .map(checkbox => checkbox.value);
      
      // Filter nodes
      const filteredNodes = allNodes.filter(node => 
        selectedNodeTypes.includes(node.originalLabel || 'Unknown')
      );
      
      // Filter edges
      const filteredEdges = allEdges.filter(edge => 
        selectedRelTypes.includes(edge.originalType || 'Unknown') &&
        filteredNodes.some(n => n.id === edge.from) &&
        filteredNodes.some(n => n.id === edge.to)
      );
      
      // Update the network
      nodes.clear();
      nodes.add(filteredNodes);
      
      edges.clear();
      edges.add(filteredEdges);
      
      // Update stats
      document.getElementById('node-count').textContent = `Nodes: ${filteredNodes.length}`;
      document.getElementById('rel-count').textContent = `Relationships: ${filteredEdges.length}`;
      
      // Automatically apply layout after filtering
      changeLayout();
      
      showToast(`Filters applied: ${filteredNodes.length} nodes, ${filteredEdges.length} relationships`);
    }

    // Select all filters
    function selectAllFilters() {
      document.querySelectorAll('#node-filter input, #relationship-filter input').forEach(checkbox => {
        checkbox.checked = true;
      });
      applyFilters();
    }

    // Clear filters
    function clearFilters() {
      document.querySelectorAll('#node-filter input, #relationship-filter input').forEach(checkbox => {
        checkbox.checked = false;
      });
      applyFilters();
    }

    // Populate configuration options
    function populateConfigOptions() {
      if (!allNodes.length || !allEdges.length) return;
      
      // Get unique properties from nodes
      const nodeProps = new Set();
      allNodes.forEach(node => {
        if (node.properties) {
          Object.keys(node.properties).forEach(prop => nodeProps.add(prop));
        }
      });
      
      const nodeLabelSelect = document.getElementById('node-label-property');
      // Keep the current selection
      const currentValue = nodeLabelSelect.value;
      nodeLabelSelect.innerHTML = '';
      
      // Add default options
      const defaultOptions = [
        { value: 'id', text: 'ID' },
        { value: 'label', text: 'Label' }
      ];
      
      defaultOptions.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.text;
        if (opt.value === currentValue) option.selected = true;
        nodeLabelSelect.appendChild(option);
      });
      
      // Add property options
      nodeProps.forEach(prop => {
        const option = document.createElement('option');
        option.value = prop;
        option.textContent = prop;
        if (prop === currentValue) option.selected = true;
        nodeLabelSelect.appendChild(option);
      });
      
      // Get unique properties from edges
      const edgeProps = new Set();
      allEdges.forEach(edge => {
        if (edge.properties) {
          Object.keys(edge.properties).forEach(prop => edgeProps.add(prop));
        }
      });
      
      const edgeLabelSelect = document.getElementById('edge-label-property');
      // Keep the current selection
      const currentEdgeValue = edgeLabelSelect.value;
      edgeLabelSelect.innerHTML = '';
      
      // Add default options
      const edgeDefaultOptions = [
        { value: 'label', text: 'Type' }
      ];
      
      edgeDefaultOptions.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.text;
        if (opt.value === currentEdgeValue) option.selected = true;
        edgeLabelSelect.appendChild(option);
      });
      
      // Add property options
      edgeProps.forEach(prop => {
        const option = document.createElement('option');
        option.value = prop;
        option.textContent = prop;
        if (prop === currentEdgeValue) option.selected = true;
        edgeLabelSelect.appendChild(option);
      });
    }

    // Apply configuration
    function applyConfig() {
      nodeLabelProperty = document.getElementById('node-label-property').value;
      edgeLabelProperty = document.getElementById('edge-label-property').value;
      
      // Update node labels
      allNodes.forEach(node => {
        let newLabel = node.id;
        
        if (nodeLabelProperty === 'label') {
          newLabel = node.originalLabel || node.label || node.id;
        } else if (node.properties && node.properties[nodeLabelProperty]) {
          newLabel = node.properties[nodeLabelProperty];
        } else if (node[nodeLabelProperty]) {
          newLabel = node[nodeLabelProperty];
        }
        
        nodes.update({ id: node.id, label: newLabel });
      });
      
      // Update edge labels
      allEdges.forEach(edge => {
        let newLabel = edge.originalType || edge.label || '';
        
        if (edgeLabelProperty === 'label') {
          newLabel = edge.originalType || edge.label || '';
        } else if (edge.properties && edge.properties[edgeLabelProperty]) {
          newLabel = edge.properties[edgeLabelProperty];
        } else if (edge[edgeLabelProperty]) {
          newLabel = edge[edgeLabelProperty];
        }
        
        edges.update({ id: edge.id, label: newLabel });
      });
      
      closeConfigPanel();
      showToast('Configuration applied successfully');
    }

    // Change layout - Fixed to prevent nodes from floating
    function changeLayout() {
      if (!network) return;
      
      const layouts = ['default', 'hierarchical', 'circular'];
      const currentIndex = layouts.indexOf(currentLayout);
      const nextIndex = (currentIndex + 1) % layouts.length;
      currentLayout = layouts[nextIndex];
      
      let layoutOptions = {};
      
      switch (currentLayout) {
        case 'hierarchical':
          layoutOptions = {
            hierarchical: {
              enabled: true,
              direction: 'UD',
              sortMethod: 'directed',
              levelSeparation: 150,
              nodeSpacing: 100
            },
            physics: {
              enabled: false // Disable physics for stable layout
            }
          };
          break;
        case 'circular':
          layoutOptions = {
            layout: {
              improvedLayout: false
            },
            physics: {
              enabled: false // Disable physics for stable layout
            }
          };
          break;
        default:
          layoutOptions = {
            hierarchical: {
              enabled: false
            },
            layout: {
              improvedLayout: true
            },
            physics: {
              enabled: false // Disable physics for stable layout
            }
          };
      }
      
      network.setOptions(layoutOptions);
      
      // Use fit instead of stabilize for better control
      network.fit({ animation: true });
      showToast(`Layout changed to: ${currentLayout}`);
    }

    // Export PNG with high resolution - FULL GRAPH
    function exportPNG(full) {
      if (!network) return;
      
      try {
        if (full) {
          // Show processing message
          showToast('Exporting full graph with high resolution... Please wait!', 5000);
          
          // Save current state
          const container = document.getElementById('viz');
          const originalWidth = container.style.width;
          const originalHeight = container.style.height;
          const currentView = network.getViewPosition();
          const currentScale = network.getScale();
          
          // Disable physics for stable export
          network.setOptions({ physics: false });
          
          // Calculate bounding box of entire graph
          const positions = network.getPositions();
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          
          Object.values(positions).forEach(pos => {
            if (pos.x < minX) minX = pos.x;
            if (pos.x > maxX) maxX = pos.x;
            if (pos.y < minY) minY = pos.y;
            if (pos.y > maxY) maxY = pos.y;
          });
          
          // Add padding (20% each side)
          const padding = 100;
          const graphWidth = (maxX - minX) + padding * 2;
          const graphHeight = (maxY - minY) + padding * 2;
          
          // Calculate optimal canvas size (min 2000px, max 8000px)
          const targetSize = Math.max(2000, Math.min(8000, Math.max(graphWidth, graphHeight)));
          const aspectRatio = graphWidth / graphHeight;
          
          let canvasWidth, canvasHeight;
          if (aspectRatio > 1) {
            canvasWidth = targetSize;
            canvasHeight = targetSize / aspectRatio;
          } else {
            canvasHeight = targetSize;
            canvasWidth = targetSize * aspectRatio;
          }
          
          // Temporarily resize container
          container.style.width = canvasWidth + 'px';
          container.style.height = canvasHeight + 'px';
          
          // Trigger redraw
          network.redraw();
          network.fit({ animation: false });
          
          // Wait for render to complete
          setTimeout(() => {
            const canvas = network.canvas.body.container.getElementsByTagName('canvas')[0];
            
            // Export with high resolution (scale 2x)
            const scale = 2;
            const highResCanvas = document.createElement('canvas');
            highResCanvas.width = canvas.width * scale;
            highResCanvas.height = canvas.height * scale;
            const ctx = highResCanvas.getContext('2d');
            
            ctx.scale(scale, scale);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.fillStyle = isDarkMode ? '#2a2a2a' : '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(canvas, 0, 0);
            
            // Export
            const dataURL = highResCanvas.toDataURL('image/png', 1.0);
            downloadImage(dataURL, `graph-full-${canvasWidth}x${canvasHeight}-hd.png`);
            
            // Restore container size
            container.style.width = originalWidth;
            container.style.height = originalHeight;
            
            // Trigger redraw and restore view
            network.redraw();
            setTimeout(() => {
              network.moveTo({ 
                position: currentView, 
                scale: currentScale, 
                animation: false 
              });
              
              // Re-enable physics if needed
              network.setOptions({ physics: false });
              
              showToast('Full graph exported successfully!');
            }, 300);
          }, 1500); // Wait 1.5 seconds for complete rendering
          
        } else {
          // Viewport export with 2x resolution
          const canvas = network.canvas.body.container.getElementsByTagName('canvas')[0];
          if (!canvas) {
            showToast('Cannot access canvas for export', 3000);
            return;
          }
          
          const scale = 2;
          const highResCanvas = document.createElement('canvas');
          highResCanvas.width = canvas.width * scale;
          highResCanvas.height = canvas.height * scale;
          const ctx = highResCanvas.getContext('2d');
          
          ctx.scale(scale, scale);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          ctx.fillStyle = isDarkMode ? '#2a2a2a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(canvas, 0, 0);
          
          const dataURL = highResCanvas.toDataURL('image/png', 1.0);
          downloadImage(dataURL, 'graph-viewport-hd.png');
          showToast('Viewport exported successfully!');
        }
      } catch (error) {
        console.error('PNG export error:', error);
        showToast('Failed to export PNG: ' + error.message, 5000);
      }
    }
    
    function downloadImage(dataURL, filename) {
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    // Export JSON
    function exportJSON() {
      if (!nodes || !edges) return;
      const data = {
        nodes: nodes.get(),
        edges: edges.get()
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'graph.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('JSON exported successfully!');
    }

    // Export CSV
    function exportCSV() {
      if (!nodes || !edges) return;
      let csv = 'type,id,label,props,from,to\n';
      nodes.get().forEach(node => {
        csv += `node,${node.id},"${node.label}","${JSON.stringify(node)}",,,\n`;
      });
      edges.get().forEach(edge => {
        csv += `edge,${edge.id},"${edge.label}","${JSON.stringify(edge)}",${edge.from},${edge.to}\n`;
      });
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'graph.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('CSV exported successfully!');
    }

    // Detail popup logic
    function showDetail(title, content) {
      document.getElementById('detail-title-text').textContent = title;
      document.getElementById('detail-content').textContent = content;
      document.getElementById('detail-popup').style.display = 'block';
    }
    
    function closeDetail() {
      document.getElementById('detail-popup').style.display = 'none';
    }
    
    function copyDetail() {
      const text = document.getElementById('detail-content').textContent;
      navigator.clipboard.writeText(text);
      showToast('Content copied to clipboard!');
    }

    // Update detail panel with clean format
    function updateDetailPanel(title, content) {
      const detailPanel = document.getElementById('detail-panel');
      const detailContent = document.getElementById('detail-panel-content');
      
      try {
        const data = JSON.parse(content);
        let formattedContent = '';
        
        if (title.startsWith('Node:')) {
          formattedContent = formatNodeDetails(data);
        } else if (title.startsWith('Edge:')) {
          formattedContent = formatEdgeDetails(data);
        } else {
          formattedContent = `<pre>${content}</pre>`;
        }
        
        detailContent.innerHTML = `
          <div><strong>${title}</strong></div>
          ${formattedContent}
        `;
      } catch (e) {
        // If not JSON, display as plain text
        detailContent.innerHTML = `
          <div><strong>${title}</strong></div>
          <pre>${content}</pre>
        `;
      }
      
      // Ensure the panel is visible
      if (detailPanel.style.display === 'none') {
        detailPanel.style.display = 'block';
      }
    }

    // Format node details in a clean way
    function formatNodeDetails(node) {
      let html = '<div class="node-details">';
      
      // Basic info
      html += `<div class="detail-section">
        <h4>Basic Information</h4>
        <div class="detail-item"><strong>ID:</strong> ${node.id}</div>
        <div class="detail-item"><strong>Label:</strong> ${node.label || 'N/A'}</div>
        <div class="detail-item"><strong>Type:</strong> ${node.originalLabel || 'N/A'}</div>
      </div>`;
      
      // Properties
      if (node.properties && Object.keys(node.properties).length > 0) {
        html += `<div class="detail-section">
          <h4>Properties</h4>`;
        
        Object.entries(node.properties).forEach(([key, value]) => {
          if (key !== 'id' && key !== 'label') {
            html += `<div class="detail-item"><strong>${key}:</strong> ${formatPropertyValue(value)}</div>`;
          }
        });
        
        html += '</div>';
      }
      
      // Vis.js specific properties
      html += `<div class="detail-section">
        <h4>Display Properties</h4>
        <div class="detail-item"><strong>Color:</strong> ${node.color || 'N/A'}</div>
        <div class="detail-item"><strong>Font Color:</strong> ${node.font?.color || 'N/A'}</div>
      </div>`;
      
      html += '</div>';
      
      return html;
    }

    // Format edge details in a clean way
    function formatEdgeDetails(edge) {
      let html = '<div class="edge-details">';
      
      // Basic info
      html += `<div class="detail-section">
        <h4>Basic Information</h4>
        <div class="detail-item"><strong>ID:</strong> ${edge.id}</div>
        <div class="detail-item"><strong>Label:</strong> ${edge.label || 'N/A'}</div>
        <div class="detail-item"><strong>Type:</strong> ${edge.originalType || 'N/A'}</div>
        <div class="detail-item"><strong>From:</strong> ${edge.from}</div>
        <div class="detail-item"><strong>To:</strong> ${edge.to}</div>
      </div>`;
      
      // Properties
      if (edge.properties && Object.keys(edge.properties).length > 0) {
        html += `<div class="detail-section">
          <h4>Properties</h4>`;
        
        Object.entries(edge.properties).forEach(([key, value]) => {
          if (key !== 'id' && key !== 'label' && key !== 'from' && key !== 'to') {
            html += `<div class="detail-item"><strong>${key}:</strong> ${formatPropertyValue(value)}</div>`;
          }
        });
        
        html += '</div>';
      }
      
      // Vis.js specific properties
      html += `<div class="detail-section">
        <h4>Display Properties</h4>
        <div class="detail-item"><strong>Color:</strong> ${edge.color?.color || 'N/A'}</div>
        <div class="detail-item"><strong>Arrows:</strong> ${edge.arrows || 'N/A'}</div>
      </div>`;
      
      html += '</div>';
      
      return html;
    }

    // Format property values for display
    function formatPropertyValue(value) {
      if (value === null || value === undefined) return 'N/A';
      if (typeof value === 'object') return JSON.stringify(value);
      return String(value);
    }

    // Theme toggle logic
    function toggleTheme() {
      const body = document.body;
      const btn = document.getElementById('theme-btn');
      isDarkMode = !isDarkMode;
      
      if (isDarkMode) {
        body.classList.remove('light');
        btn.textContent = 'üåô Light Mode';
        
        // Update network colors for dark mode
        if (network) {
          network.setOptions({
            nodes: {
              font: {
                color: '#fff'
              }
            },
            edges: {
              font: {
                color: '#ffffff',
                background: 'rgba(0,0,0,0.8)',
                strokeColor: '#000000'
              }
            }
          });
        }
      } else {
        body.classList.add('light');
        btn.textContent = '‚òÄÔ∏è Dark Mode';
        
        // Update network colors for light mode - FIX for node labels
        if (network) {
          network.setOptions({
            nodes: {
              font: {
                color: '#000000'  // Fixed: black text in light mode
              }
            },
            edges: {
              font: {
                color: '#000000',
                background: 'rgba(255,255,255,0.9)',
                strokeColor: '#ffffff'
              }
            }
          });
        }
      }
    }

    // Zoom to fit function
    function zoomToFit() {
      if (network) {
        network.fit({ animation: true });
        showToast('Zoomed to fit all nodes');
      }
    }

    // Reset view function
    function resetView() {
      if (network && globalThis.initialView) {
        network.moveTo({ position: globalThis.initialView, scale: 1, animation: true });
        showToast('View reset to initial state');
      } else if (network) {
        network.fit({ animation: true });
        showToast('Zoomed to fit all nodes');
      }
    }

    // Get token from URL
    const urlParams = new URLSearchParams(globalThis.location.search);
    const token = urlParams.get('token') || globalThis.location.pathname.split('/').pop();
    currentEmbedToken = token; // Store in global variable

    let lastSearchedNodeId = null;

    // Color generator for labels/types
    function stringToColor(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
      }
      let color = '#';
      for (let i = 0; i < 3; i++) {
        const value = (hash >> (i * 8)) & 0xFF;
        color += ('00' + value.toString(16)).slice(-2);
      }
      return color;
    }

    // Load mock data for testing
    function loadMockData() {
      // Hide loading if visible
      document.getElementById('loading').classList.add('hidden');
      
      // Create mock data
      const mockNodes = [
        { id: '1', label: 'John Doe', type: 'Person', age: 32, city: 'New York' },
        { id: '2', label: 'Jane Smith', type: 'Person', age: 28, city: 'Los Angeles' },
        { id: '3', label: 'TechCorp Inc.', type: 'Company', industry: 'Technology', employees: 500 },
        { id: '4', label: 'Finance LLC', type: 'Company', industry: 'Finance', employees: 150 },
        { id: '5', label: 'Project Alpha', type: 'Project', status: 'Active', budget: 100000 },
        { id: '6', label: 'Project Beta', type: 'Project', status: 'Completed', budget: 75000 },
        { id: '7', label: 'Marketing Dept', type: 'Department', manager: 'Jane Smith', size: 25 },
        { id: '8', label: 'Engineering Dept', type: 'Department', manager: 'John Doe', size: 50 }
      ];
      
      const mockEdges = [
        { id: '1', from: '1', to: '3', label: 'WORKS_AT', role: 'Developer', since: '2020' },
        { id: '2', from: '2', to: '3', label: 'WORKS_AT', role: 'Manager', since: '2019' },
        { id: '3', from: '1', to: '5', label: 'LEADS', since: '2021' },
        { id: '4', from: '2', to: '6', label: 'MANAGED', duration: '2 years' },
        { id: '5', from: '3', to: '5', label: 'OWNS', investment: 50000 },
        { id: '6', from: '4', to: '6', label: 'FUNDED', amount: 25000 },
        { id: '7', from: '5', to: '7', label: 'USES', usage: 'Marketing' },
        { id: '8', from: '6', to: '8', label: 'DEVELOPED_BY', effort: '6 months' },
        { id: '9', from: '1', to: '8', label: 'MANAGES', since: '2022' },
        { id: '10', from: '3', to: '4', label: 'PARTNERS_WITH', since: '2021' }
      ];
      
      // Transform to vis.js format using spread operator
      const visNodes = mockNodes.map(node => ({
        ...node, // Spread all properties from the original node
        title: `${node.type}: ${JSON.stringify(node, null, 2)}`,
        color: stringToColor(node.type),
        font: { color: isDarkMode ? '#fff' : '#000' },
        properties: node,
        originalLabel: node.type
      }));
      
      const visEdges = mockEdges.map(edge => ({
        ...edge, // Spread all properties from the original edge
        title: JSON.stringify(edge, null, 2),
        arrows: 'to',
        color: { color: stringToColor(edge.label) },
        properties: edge,
        originalType: edge.label
      }));
      
      // Destroy existing network if it exists
      if (network) {
        network.destroy();
        network = null;
      }
      
      // Store all nodes and edges for filtering
      allNodes = visNodes;
      allEdges = visEdges;
      
      // Create vis.js network
      nodes = new vis.DataSet(visNodes);
      edges = new vis.DataSet(visEdges);
      
      const container = document.getElementById('viz');
      const data = { nodes, edges };
      const options = {
        nodes: {
          shape: 'dot',
          size: 30,
          font: {
            size: 14,
            color: isDarkMode ? '#fff' : '#000'
          },
          borderWidth: 2
        },
        edges: {
          width: 2,
          font: {
            size: 12,
            color: isDarkMode ? '#ffffff' : '#000000',
            background: isDarkMode ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.9)',
            strokeWidth: 2,
            strokeColor: isDarkMode ? '#000000' : '#ffffff',
            align: 'middle'
          },
          smooth: {
            type: 'continuous'
          }
        },
        physics: {
          enabled: false, // Disable physics to prevent floating nodes
          stabilization: {
            iterations: 100
          }
        },
        interaction: {
          hover: true,
          tooltipDelay: 100,
          dragNodes: true,
          dragView: true,
          selectable: true,
          selectConnectedEdges: true
        },
        manipulation: {
          enabled: false
        }
      };
      
      network = new vis.Network(container, data, options);
      
      // Save initial view
      globalThis.initialView = network.getViewPosition ? network.getViewPosition() : null;
      
      // Node/edge click event - show detail in panel
      network.on('click', function(params) {
        if (params.nodes.length > 0) {
          const nodeId = params.nodes[0];
          const node = nodes.get(nodeId);
          updateDetailPanel('Node: ' + node.label, JSON.stringify(node, null, 2));
        } else if (params.edges.length > 0) {
          const edgeId = params.edges[0];
          const edge = edges.get(edgeId);
          updateDetailPanel('Edge: ' + edge.label, JSON.stringify(edge, null, 2));
        }
      });
      
      // Update stats
      document.getElementById('node-count').textContent = `Nodes: ${visNodes.length}`;
      document.getElementById('rel-count').textContent = `Relationships: ${visEdges.length}`;
      
      showToast('Mock data loaded successfully!');
    }

    async function loadVisualization() {
      // For demo purposes, we'll load mock data if no token is provided
      if (!currentEmbedToken || currentEmbedToken === 'undefined' || currentEmbedToken === 'null') {
        loadMockData();
        return;
      }
      
      try {
        // First, get the embed data for this token
        const embedResponse = await fetch(`/api/embed/${currentEmbedToken}`);
        
        if (!embedResponse.ok) {
          if (embedResponse.status === 404) {
            globalThis.location.href = '/static/embed-not-found.html';
            return;
          }
          if (embedResponse.status === 410) {
            globalThis.location.href = '/static/embed-expired.html';
            return;
          }
          throw new Error(`Failed to get embed data: ${embedResponse.statusText}`);
        }

        const embedData = await embedResponse.json();
        
        if (!embedData.success) {
          throw new Error('Failed to get embed data');
        }

        const cypherQuery = embedData.data.cypherQuery;

        // Execute the cypher query through proxy
        const queryResponse = await fetch('/api/proxy/query', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            cypher: cypherQuery,
            params: {}
          })
        });

        if (!queryResponse.ok) {
          throw new Error(`Query failed: ${queryResponse.statusText}`);
        }

        const queryResult = await queryResponse.json();
        
        if (!queryResult.success) {
          // Normalize error to a friendly string so the catch-block can show it
          let errMsg = 'Query execution failed';
          try {
            if (!queryResult.error) {
              errMsg = 'Query execution failed';
            } else if (typeof queryResult.error === 'string') {
              errMsg = queryResult.error;
            } else if (queryResult.error.message) {
              errMsg = queryResult.error.message;
            } else {
              errMsg = JSON.stringify(queryResult.error);
            }
          } catch (e) {
            errMsg = 'Query execution failed (unknown error)';
          }
          throw new Error(errMsg);
        }

        // Transform Neo4j data to vis.js format
        const visNodes = [];
        const visEdges = [];
        const nodeIds = new Set(); // Track unique node IDs
        const edgeIds = new Set(); // Track unique edge IDs

        // Helper to add a node if not exists
        function addNode(id, label, props, originalLabel) {
          if (!nodeIds.has(id)) {
            const displayLabel = (props && (props.name || props.title)) || id;
            visNodes.push({
              id: id,
              label: displayLabel,
              title: `${label}: ${JSON.stringify(props || {})}`,
              color: stringToColor(label || 'Node'),
              font: { color: isDarkMode ? '#fff' : '#000' },
              properties: props,
              originalLabel: originalLabel || label
            });
            nodeIds.add(id);
          }
        }

        // The proxy may return either a graph-shaped response (with .data.nodes and .data.relationships)
        // or a tabular array of rows (each record is an object with p,r,m keys). Handle both.
        if (queryResult.data && queryResult.data.nodes && queryResult.data.relationships) {
          // Graph-shaped response
          queryResult.data.nodes.forEach(node => {
            if (!nodeIds.has(node.id)) {
              const label = node.labels && node.labels[0] ? node.labels[0] : 'Node';
              const props = node.properties || {};
              addNode(node.id, label, props, label);
            }
          });

          queryResult.data.relationships.forEach(rel => {
            if (!edgeIds.has(rel.id)) {
              const props = rel.properties || {};
              visEdges.push({
                id: rel.id,
                from: rel.startNode,
                to: rel.endNode,
                label: rel.type,
                title: JSON.stringify(props),
                arrows: 'to',
                color: { color: stringToColor(rel.type) },
                properties: props,
                originalType: rel.type
              });
              edgeIds.add(rel.id);
            }
          });
        } else if (Array.isArray(queryResult.data)) {
          // Tabular rows: try to map row values to nodes/relationships
          // Use a signature map to dedupe nodes by label+key (e.g., Person:Keanu Reeves)
          const nodeSigToId = new Map();
          let syntheticIdCounter = 1;

          function makeNodeId(label, props) {
            // prefer name or title as stable identifier
            const key = props && (props.name || props.title || props.id);
            const sig = label + '::' + (key || JSON.stringify(props || {}));
            if (nodeSigToId.has(sig)) return nodeSigToId.get(sig);
            const id = `${label || 'N'}_${(key || '').toString().replace(/\s+/g, '_') || syntheticIdCounter++}`;
            nodeSigToId.set(sig, id);
            return id;
          }

          queryResult.data.forEach((row, rowIndex) => {
            // row may be an object with keys mapping to values
            if (row && typeof row === 'object') {
              Object.entries(row).forEach(([key, val]) => {
                // Relationship encoded as array [startProps, type, endProps]
                if (Array.isArray(val) && val.length >= 3) {
                  const startProps = val[0] || {};
                  const relType = val[1] || 'REL';
                  const endProps = val[2] || {};

                  // Infer labels from data, not fixed to Person/Movie
                  const startLabel = Object.keys(startProps).length > 0 ? 
                    (startProps.label || 'Node') : 'Node';
                  const endLabel = Object.keys(endProps).length > 0 ? 
                    (endProps.label || 'Node') : 'Node';
                  
                  const fromId = makeNodeId(startLabel, startProps);
                  const toId = makeNodeId(endLabel, endProps);
                  addNode(fromId, startLabel, startProps, startLabel);
                  addNode(toId, endLabel, endProps, endLabel);

                  const edgeId = `${fromId}_${relType}_${toId}_${rowIndex}`;
                  if (!edgeIds.has(edgeId)) {
                    visEdges.push({
                      id: edgeId,
                      from: fromId,
                      to: toId,
                      label: relType,
                      title: JSON.stringify({}),
                      arrows: 'to',
                      color: { color: stringToColor(relType) },
                      properties: {},
                      originalType: relType
                    });
                    edgeIds.add(edgeId);
                  }
                } else if (val && typeof val === 'object') {
                  // Plain object ‚Äî treat as node
                  // Use the actual label from data if available
                  let label = (key && key.length <= 3) ? key.toUpperCase() : (key.charAt(0).toUpperCase() + key.slice(1));
                  // If object contains label, use it
                  if (val.label) label = val.label;
                  else if (val.title) label = 'Movie';
                  else if (val.name) label = 'Person';
                  
                  const id = makeNodeId(label, val);
                  addNode(id, label, val, label);
                }
              });
            }
          });
        } else {
          // Unexpected shape: show no nodes
          console.warn('Unexpected queryResult.data shape', queryResult.data);
        }

        // Destroy existing network if it exists
        if (network) {
          network.destroy();
          network = null;
        }

        // Store all nodes and edges for filtering
        allNodes = visNodes;
        allEdges = visEdges;

        // Create vis.js network
        nodes = new vis.DataSet(visNodes);
        edges = new vis.DataSet(visEdges);

        const container = document.getElementById('viz');
        const data = { nodes, edges };
        const options = {
          nodes: {
            shape: 'dot',
            size: 30,
            font: {
              size: 14,
              color: isDarkMode ? '#fff' : '#000'
            },
            borderWidth: 2
          },
          edges: {
            width: 2,
            font: {
              size: 12,
              color: isDarkMode ? '#ffffff' : '#000000',
              background: isDarkMode ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.9)',
              strokeWidth: 2,
              strokeColor: isDarkMode ? '#000000' : '#ffffff',
              align: 'middle'
            },
            smooth: {
              type: 'continuous'
            }
          },
          physics: {
            enabled: false, // Disable physics to prevent floating nodes
            stabilization: {
              iterations: 100
            }
          },
          interaction: {
            hover: true,
            tooltipDelay: 100,
            dragNodes: true,
            dragView: true,
            selectable: true,
            selectConnectedEdges: true
          },
          manipulation: {
            enabled: false
          }
        };

        network = new vis.Network(container, data, options);
        
        // Save initial view
        globalThis.initialView = network.getViewPosition ? network.getViewPosition() : null;

        // Node/edge click event - show detail in panel
        network.on('click', function(params) {
          if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            const node = nodes.get(nodeId);
            updateDetailPanel('Node: ' + node.label, JSON.stringify(node, null, 2));
          } else if (params.edges.length > 0) {
            const edgeId = params.edges[0];
            const edge = edges.get(edgeId);
            updateDetailPanel('Edge: ' + edge.label, JSON.stringify(edge, null, 2));
          }
        });

        // Hide loading spinner
        document.getElementById('loading').classList.add('hidden');

        // Update stats
        document.getElementById('node-count').textContent = `Nodes: ${visNodes.length}`;
        document.getElementById('rel-count').textContent = `Relationships: ${visEdges.length}`;

        showToast('Graph visualization loaded successfully!');

      } catch (error) {
        // Ensure we show a useful error message even when `error` is an object
        console.error('Error:', error);
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('error').classList.add('show');
        let msg = 'Unknown error';
        try {
          if (!error) msg = 'Unknown error';
          else if (typeof error === 'string') msg = error;
          else if (error.message) msg = error.message;
          else msg = JSON.stringify(error);
        } catch (e) {
          msg = String(error);
        }
        document.getElementById('error-message').textContent = msg;
      }
    }

    function reload() {
      globalThis.location.reload();
    }

    // Load visualization on page load
    loadVisualization();

    // Search node by name/id
    function searchNode() {
      const query = document.getElementById('search-node').value.trim().toLowerCase();
      if (!query || !nodes) return;
      let found = null;
      nodes.forEach(function(node) {
        const label = (node.label || '').toLowerCase();
        const id = (node.id || '').toString().toLowerCase();
        if (label.includes(query) || id === query) {
          found = node.id;
        }
      });
      if (found) {
        lastSearchedNodeId = found;
        network.selectNodes([found]);
        network.focus(found, { scale: 1.5, animation: true });
        showToast(`Node "${query}" found and focused`);
      } else {
        showToast(`Node "${query}" not found!`);
      }
    }

    // Allow Enter key to trigger search
    document.getElementById('search-node').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        searchNode();
      }
    });
  </script>

  <style>
    /* Additional styles for clean detail formatting */
    .node-details, .edge-details {
      font-size: 14px;
    }
    
    .detail-section {
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .detail-section h4 {
      margin-bottom: 8px;
      font-size: 14px;
      font-weight: 600;
      color: var(--primary-color);
    }
    
    .detail-item {
      margin-bottom: 6px;
      display: flex;
    }
    
    .detail-item strong {
      min-width: 120px;
      margin-right: 8px;
    }
    
    body.light .detail-section {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    body.light .detail-section h4 {
      color: var(--primary-dark);
    }
  </style>
</body>
</html>
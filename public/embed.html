<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neo4j Graph Visualization</title>
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #1a1a1a;
      color: #fff;
      overflow: hidden;
      transition: background-color 0.3s, color 0.3s;
    }

    /* Light mode styles */
    body.light {
      background: #f5f5f5;
      color: #333;
    }

    body.light #viz {
      background: #ffffff;
    }

    body.light .controls {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
    }

    body.light .info {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
    }

    body.light #detail-popup {
      background: #fff;
      color: #333;
    }

    body.light #detail-content {
      background: #f8f8f8;
      color: #333;
    }

    #viz {
      width: 100vw;
      height: 100vh;
      background: #2a2a2a;
      transition: background-color 0.3s;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 1000;
    }

    #loading.hidden {
      display: none;
    }

    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      border-top: 4px solid #4CAF50;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #error {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #ff4444;
      padding: 20px 40px;
      border-radius: 8px;
      text-align: center;
      max-width: 500px;
      display: none;
    }

    #error.show {
      display: block;
    }

    #error h2 {
      margin-bottom: 10px;
    }

    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
    }

    .controls button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .controls button:hover {
      background: #45a049;
    }

    .info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <p>Loading visualization...</p>
  </div>

  <div id="error">
    <h2>Error Loading Visualization</h2>
    <p id="error-message"></p>
  </div>

  <div id="viz"></div>

  <div id="detail-popup" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#222;color:#fff;padding:24px 32px;border-radius:10px;z-index:200;min-width:320px;max-width:90vw;box-shadow:0 4px 24px #000a;">
    <div id="detail-title" style="font-weight:bold;font-size:18px;margin-bottom:8px;"></div>
    <pre id="detail-content" style="background:#111;padding:12px;border-radius:6px;max-height:300px;overflow:auto;font-size:14px;"></pre>
    <button onclick="copyDetail()" style="margin-top:8px;background:#4CAF50;color:#fff;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;">Copy</button>
    <button onclick="closeDetail()" style="margin-top:8px;margin-left:8px;background:#888;color:#fff;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;">Close</button>
  </div>

  <div class="controls">
    <input type="text" id="search-node" placeholder="Search node by name/id" style="margin-right:8px;padding:8px;border-radius:4px;border:none;width:160px;">
    <button onclick="searchNode()">üîç Search</button>
    <button onclick="exportJSON()">üíæ Export JSON</button>
    <button onclick="exportCSV()">üíæ Export CSV</button>
    <button onclick="exportPNG(false)">üñºÔ∏è Export PNG (viewport)</button>
    <button onclick="exportPNG(true)">üñºÔ∏è Export PNG (full graph)</button>
    <button onclick="toggleTheme()" id="theme-btn">üåô Light Mode</button>
    <button onclick="zoomToFit()">üîé Zoom to Fit</button>
    <button onclick="resetView()">üîÑ Reset View</button>
    <button onclick="stabilize()">‚ö° Stabilize</button>
    <button onclick="reload()">‚ü≥ Reload</button>
  </div>

  <div class="info">
    <div id="node-count">Nodes: 0</div>
    <div id="rel-count">Relationships: 0</div>
  </div>

  <script>
    // Global variables
    let network = null;
    let nodes = null;
    let edges = null;
    let currentEmbedToken = null;
    let isDarkMode = true;

    // Export PNG with high resolution - FULL GRAPH
    function exportPNG(full) {
      if (!network) return;
      
      try {
        if (full) {
          // Hi·ªÉn th·ªã th√¥ng b√°o ƒëang x·ª≠ l√Ω
          const loadingMsg = document.createElement('div');
          loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);color:#fff;padding:20px 40px;border-radius:8px;z-index:9999;font-size:16px;';
          loadingMsg.textContent = 'ƒêang export full graph v·ªõi high resolution... Vui l√≤ng ch·ªù!';
          document.body.appendChild(loadingMsg);

          // L∆∞u tr·∫°ng th√°i hi·ªán t·∫°i
          const container = document.getElementById('viz');
          const originalWidth = container.style.width;
          const originalHeight = container.style.height;
          const currentView = network.getViewPosition();
          const currentScale = network.getScale();
          const currentPhysics = network.physics.physicsEnabled;
          
          // Disable physics
          network.setOptions({ physics: false });
          
          // T√≠nh to√°n bounding box c·ªßa to√†n b·ªô graph
          const positions = network.getPositions();
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          
          Object.values(positions).forEach(pos => {
            if (pos.x < minX) minX = pos.x;
            if (pos.x > maxX) maxX = pos.x;
            if (pos.y < minY) minY = pos.y;
            if (pos.y > maxY) maxY = pos.y;
          });
          
          // Th√™m padding (20% m·ªói b√™n)
          const padding = 100;
          const graphWidth = (maxX - minX) + padding * 2;
          const graphHeight = (maxY - minY) + padding * 2;
          
          // T√≠nh k√≠ch th∆∞·ªõc canvas t·ªëi ∆∞u (t·ªëi thi·ªÉu 2000px, t·ªëi ƒëa 8000px)
          const targetSize = Math.max(2000, Math.min(8000, Math.max(graphWidth, graphHeight)));
          const aspectRatio = graphWidth / graphHeight;
          
          let canvasWidth, canvasHeight;
          if (aspectRatio > 1) {
            canvasWidth = targetSize;
            canvasHeight = targetSize / aspectRatio;
          } else {
            canvasHeight = targetSize;
            canvasWidth = targetSize * aspectRatio;
          }
          
          // Resize container t·∫°m th·ªùi
          container.style.width = canvasWidth + 'px';
          container.style.height = canvasHeight + 'px';
          
          // Trigger redraw
          network.redraw();
          network.fit({ animation: false });
          
          // ƒê·ª£i ƒë·ªÉ render ho√†n t·∫•t
          setTimeout(() => {
            const canvas = network.canvas.body.container.getElementsByTagName('canvas')[0];
            
            // Export v·ªõi resolution cao (scale 2x n·ªØa)
            const scale = 2;
            const highResCanvas = document.createElement('canvas');
            highResCanvas.width = canvas.width * scale;
            highResCanvas.height = canvas.height * scale;
            const ctx = highResCanvas.getContext('2d');
            
            ctx.scale(scale, scale);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.fillStyle = isDarkMode ? '#2a2a2a' : '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(canvas, 0, 0);
            
            // Export
            const dataURL = highResCanvas.toDataURL('image/png', 1.0);
            downloadImage(dataURL, `graph-full-${canvasWidth}x${canvasHeight}-hd.png`);
            
            // Restore container size
            container.style.width = originalWidth;
            container.style.height = originalHeight;
            
            // Trigger redraw v√† restore view
            network.redraw();
            setTimeout(() => {
              network.moveTo({ 
                position: currentView, 
                scale: currentScale, 
                animation: false 
              });
              if (currentPhysics) {
                network.setOptions({ physics: true });
              }
              loadingMsg.remove();
            }, 300);
          }, 1500); // ƒê·ª£i 1.5 gi√¢y ƒë·ªÉ render ho√†n ch·ªânh
          
        } else {
          // Viewport export with 2x resolution
          const canvas = network.canvas.body.container.getElementsByTagName('canvas')[0];
          if (!canvas) {
            alert('Cannot access canvas for export');
            return;
          }
          
          const scale = 2;
          const highResCanvas = document.createElement('canvas');
          highResCanvas.width = canvas.width * scale;
          highResCanvas.height = canvas.height * scale;
          const ctx = highResCanvas.getContext('2d');
          
          ctx.scale(scale, scale);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          ctx.fillStyle = isDarkMode ? '#2a2a2a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(canvas, 0, 0);
          
          const dataURL = highResCanvas.toDataURL('image/png', 1.0);
          downloadImage(dataURL, 'graph-viewport-hd.png');
        }
      } catch (error) {
        console.error('PNG export error:', error);
        alert('Failed to export PNG: ' + error.message);
      }
    }
    
    function downloadImage(dataURL, filename) {
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
    // Export JSON
    function exportJSON() {
      if (!nodes || !edges) return;
      const data = {
        nodes: nodes.get(),
        edges: edges.get()
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'graph.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Export CSV
    function exportCSV() {
      if (!nodes || !edges) return;
      let csv = 'type,id,label,props,from,to\n';
      nodes.get().forEach(node => {
        csv += `node,${node.id},"${node.label}","${JSON.stringify(node)}",,,\n`;
      });
      edges.get().forEach(edge => {
        csv += `edge,${edge.id},"${edge.label}","${JSON.stringify(edge)}",${edge.from},${edge.to}\n`;
      });
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'graph.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    // Layout change logic removed as requested
  let initialView = null;
    // Detail popup logic
    function showDetail(title, content) {
      document.getElementById('detail-title').textContent = title;
      document.getElementById('detail-content').textContent = content;
      document.getElementById('detail-popup').style.display = 'block';
    }
    function closeDetail() {
      document.getElementById('detail-popup').style.display = 'none';
    }
    function copyDetail() {
      const text = document.getElementById('detail-content').textContent;
      navigator.clipboard.writeText(text);
    }
    // Theme toggle logic
    function toggleTheme() {
      const body = document.body;
      const btn = document.getElementById('theme-btn');
      isDarkMode = !isDarkMode;
      
      if (isDarkMode) {
        body.classList.remove('light');
        btn.textContent = 'üåô Light Mode';
        
        // Update edge font colors for dark mode
        if (network) {
          network.setOptions({
            edges: {
              font: {
                color: '#ffffff',
                background: 'rgba(0,0,0,0.8)',
                strokeColor: '#000000'
              }
            }
          });
        }
      } else {
        body.classList.add('light');
        btn.textContent = '‚òÄÔ∏è Dark Mode';
        
        // Update edge font colors for light mode
        if (network) {
          network.setOptions({
            edges: {
              font: {
                color: '#000000',
                background: 'rgba(255,255,255,0.9)',
                strokeColor: '#ffffff'
              }
            }
          });
        }
      }
    }

    // Zoom to fit function
    function zoomToFit() {
      if (network) {
        network.fit({ animation: true });
      }
    }

    // Reset view function
    function resetView() {
      if (network && globalThis.initialView) {
        network.moveTo({ position: globalThis.initialView, scale: 1, animation: true });
      } else if (network) {
        network.fit({ animation: true });
      }
    }

    // Get token from URL
    const urlParams = new URLSearchParams(globalThis.location.search);
    const token = urlParams.get('token') || globalThis.location.pathname.split('/').pop();
    currentEmbedToken = token; // Store in global variable

    let lastSearchedNodeId = null;

    async function loadVisualization() {
      try {
        // First, get the embed data for this token
        const embedResponse = await fetch(`/api/embed/${currentEmbedToken}`);
        
        if (!embedResponse.ok) {
          if (embedResponse.status === 404) {
            globalThis.location.href = '/static/embed-not-found.html';
            return;
          }
          if (embedResponse.status === 410) {
            globalThis.location.href = '/static/embed-expired.html';
            return;
          }
          throw new Error(`Failed to get embed data: ${embedResponse.statusText}`);
        }

        const embedData = await embedResponse.json();
        
        if (!embedData.success) {
          throw new Error('Failed to get embed data');
        }

        const cypherQuery = embedData.data.cypherQuery;

        // Execute the cypher query through proxy
        const queryResponse = await fetch('/api/proxy/query', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            cypher: cypherQuery,
            params: {}
          })
        });

        if (!queryResponse.ok) {
          throw new Error(`Query failed: ${queryResponse.statusText}`);
        }

        const queryResult = await queryResponse.json();
        
        if (!queryResult.success) {
          // Normalize error to a friendly string so the catch-block can show it
          let errMsg = 'Query execution failed';
          try {
            if (!queryResult.error) {
              errMsg = 'Query execution failed';
            } else if (typeof queryResult.error === 'string') {
              errMsg = queryResult.error;
            } else if (queryResult.error.message) {
              errMsg = queryResult.error.message;
            } else {
              errMsg = JSON.stringify(queryResult.error);
            }
          } catch (e) {
            errMsg = 'Query execution failed (unknown error)';
          }
          throw new Error(errMsg);
        }

        // Color generator for labels/types
        function stringToColor(str) {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
          }
          let color = '#';
          for (let i = 0; i < 3; i++) {
            const value = (hash >> (i * 8)) & 0xFF;
            color += ('00' + value.toString(16)).slice(-2);
          }
          return color;
        }

        // Transform Neo4j data to vis.js format
        const visNodes = [];
        const visEdges = [];
        const nodeIds = new Set(); // Track unique node IDs
        const edgeIds = new Set(); // Track unique edge IDs

        // Helper to add a node if not exists
        function addNode(id, label, props) {
          if (!nodeIds.has(id)) {
            const displayLabel = (props && (props.name || props.title)) || id;
            visNodes.push({
              id: id,
              label: displayLabel,
              title: `${label}: ${JSON.stringify(props || {})}`,
              color: stringToColor(label || 'Node'),
              font: { color: '#fff' }
            });
            nodeIds.add(id);
          }
        }

        // The proxy may return either a graph-shaped response (with .data.nodes and .data.relationships)
        // or a tabular array of rows (each record is an object with p,r,m keys). Handle both.
        if (queryResult.data && queryResult.data.nodes && queryResult.data.relationships) {
          // Graph-shaped response
          queryResult.data.nodes.forEach(node => {
            if (!nodeIds.has(node.id)) {
              const label = node.labels && node.labels[0] ? node.labels[0] : 'Node';
              const props = node.properties || {};
              addNode(node.id, label, props);
            }
          });

          queryResult.data.relationships.forEach(rel => {
            if (!edgeIds.has(rel.id)) {
              const props = rel.properties || {};
              visEdges.push({
                id: rel.id,
                from: rel.startNode,
                to: rel.endNode,
                label: rel.type,
                title: JSON.stringify(props),
                arrows: 'to',
                color: { color: stringToColor(rel.type) }
              });
              edgeIds.add(rel.id);
            }
          });
        } else if (Array.isArray(queryResult.data)) {
          // Tabular rows: try to map row values to nodes/relationships
          // Use a signature map to dedupe nodes by label+key (e.g., Person:Keanu Reeves)
          const nodeSigToId = new Map();
          let syntheticIdCounter = 1;

          function makeNodeId(label, props) {
            // prefer name or title as stable identifier
            const key = props && (props.name || props.title || props.id);
            const sig = label + '::' + (key || JSON.stringify(props || {}));
            if (nodeSigToId.has(sig)) return nodeSigToId.get(sig);
            const id = `${label || 'N'}_${(key || '').toString().replace(/\s+/g, '_') || syntheticIdCounter++}`;
            nodeSigToId.set(sig, id);
            return id;
          }

          queryResult.data.forEach((row, rowIndex) => {
            // row may be an object with keys mapping to values
            if (row && typeof row === 'object') {
              Object.entries(row).forEach(([key, val]) => {
                // Relationship encoded as array [startProps, type, endProps]
                if (Array.isArray(val) && val.length >= 3) {
                  const startProps = val[0] || {};
                  const relType = val[1] || 'REL';
                  const endProps = val[2] || {};

                  // Infer labels from surrounding keys if possible
                  const startLabel = 'Person';
                  const endLabel = 'Movie';
                  const fromId = makeNodeId(startLabel, startProps);
                  const toId = makeNodeId(endLabel, endProps);
                  addNode(fromId, startLabel, startProps);
                  addNode(toId, endLabel, endProps);

                  const edgeId = `${fromId}_${relType}_${toId}_${rowIndex}`;
                  if (!edgeIds.has(edgeId)) {
                    visEdges.push({
                      id: edgeId,
                      from: fromId,
                      to: toId,
                      label: relType,
                      title: JSON.stringify({}),
                      arrows: 'to',
                      color: { color: stringToColor(relType) }
                    });
                    edgeIds.add(edgeId);
                  }
                } else if (val && typeof val === 'object') {
                  // Plain object ‚Äî treat as node
                  // Infer label from key if it looks like p/m or similar
                  let label = (key && key.length <= 3) ? key.toUpperCase() : (key.charAt(0).toUpperCase() + key.slice(1));
                  // If object contains title it's likely a Movie, if name -> Person
                  if (val.title) label = 'Movie';
                  else if (val.name) label = 'Person';
                  const id = makeNodeId(label, val);
                  addNode(id, label, val);
                }
              });
            }
          });
        } else {
          // Unexpected shape: show no nodes
          console.warn('Unexpected queryResult.data shape', queryResult.data);
        }

        // Destroy existing network if it exists
        if (network) {
          network.destroy();
          network = null;
        }

        // Create vis.js network
        nodes = new vis.DataSet(visNodes);
        edges = new vis.DataSet(visEdges);

        const container = document.getElementById('viz');
        const data = { nodes, edges };
        const options = {
          nodes: {
            shape: 'dot',
            size: 30,
            font: {
              size: 14,
              color: '#fff'
            },
            borderWidth: 2
          },
          edges: {
            width: 2,
            font: {
              size: 12,
              color: '#ffffff',
              background: 'rgba(0,0,0,0.8)',
              strokeWidth: 2,
              strokeColor: '#000000',
              align: 'middle'
            },
            smooth: {
              type: 'continuous'
            }
          },
          physics: {
            stabilization: {
              iterations: 200
            },
            barnesHut: {
              gravitationalConstant: -30000,
              springConstant: 0.001,
              springLength: 200
            }
          },
          interaction: {
            hover: true,
            tooltipDelay: 100
          }
        };

        network = new vis.Network(container, data, options);
        // Drag & drop: gi·ªØ v·ªã tr√≠ node sau khi di chuy·ªÉn
        network.on('dragEnd', function(params) {
          if (params.nodes && params.nodes.length > 0) {
            network.setOptions({ physics: false });
          }
        });
        // Save initial view
        globalThis.initialView = network.getViewPosition ? network.getViewPosition() : null;

        // Node/edge click event - only show detail info
        network.on('click', function(params) {
          if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            const node = nodes.get(nodeId);
            showDetail('Node: ' + node.label, JSON.stringify(node, null, 2));
          } else if (params.edges.length > 0) {
            const edgeId = params.edges[0];
            const edge = edges.get(edgeId);
            showDetail('Edge: ' + edge.label, JSON.stringify(edge, null, 2));
          }
        });

        // Hide loading spinner
        document.getElementById('loading').classList.add('hidden');

        // Update stats
        document.getElementById('node-count').textContent = `Nodes: ${visNodes.length}`;
        document.getElementById('rel-count').textContent = `Relationships: ${visEdges.length}`;

        // Handle stabilization
        network.on('stabilizationIterationsDone', function() {
          network.setOptions({ physics: false });
        });

      } catch (error) {
        // Ensure we show a useful error message even when `error` is an object
        console.error('Error:', error);
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('error').classList.add('show');
        let msg = 'Unknown error';
        try {
          if (!error) msg = 'Unknown error';
          else if (typeof error === 'string') msg = error;
          else if (error.message) msg = error.message;
          else msg = JSON.stringify(error);
        } catch (e) {
          msg = String(error);
        }
        document.getElementById('error-message').textContent = msg;
      }
    }

    function stabilize() {
      if (network) {
        network.stabilize();
      }
    }

    function reload() {
      globalThis.location.reload();
    }

    // Load visualization on page load
    loadVisualization();

    // Search node by name/id
    function searchNode() {
      const query = document.getElementById('search-node').value.trim().toLowerCase();
      if (!query || !nodes) return;
      let found = null;
      nodes.forEach(function(node) {
        const label = (node.label || '').toLowerCase();
        const id = (node.id || '').toString().toLowerCase();
        if (label.includes(query) || id === query) {
          found = node.id;
        }
      });
      if (found) {
        lastSearchedNodeId = found;
        network.selectNodes([found]);
        network.focus(found, { scale: 1.5, animation: true });
      } else {
        alert('Node not found!');
      }
    }
  </script>
</body>
</html>
